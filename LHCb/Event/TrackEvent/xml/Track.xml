<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE gdd SYSTEM 'gdd.dtd'>
<gdd>
  <package name='TrackEvent'>

<!-- ==================== Track class definition ==================== -->

    <class
      name        = 'Track'
      author      = 'Jose Hernando, Eduardo Rodrigues'
      desc        = 'Track is the base class for offline and online tracks.'
      id          = '10010'
      location    = 'Rec/Track/Best'
      keyedContTypeDef = "TRUE"
      stdVectorTypeDef = "TRUE">

      <location name="Ideal"      place="MC/Track/Ideal"/>
      <location name="Seed"       place="Rec/Track/Seed"/>
      <location name="RZVelo"     place="Rec/Track/RZVelo"/>
      <location name="Velo"       place="Rec/Track/Velo"/>
      <location name="Forward"    place="Rec/Track/Forward"/>
      <location name="VeloTT"     place="Rec/Track/VeloTT"/>
      <location name="TT"         place="Rec/Track/TT"/>
      <location name="Match"      place="Rec/Track/Match"/>
      <location name="Downstream" place="Rec/Track/Downstream"/>
      <location name="Tsa"        place="Rec/Track/Tsa"/>
      <location name="Muon"       place="Rec/Track/Muon"/>
      <location name="VP"    place="Rec/Track/VP"/>
      <location name="VPTT"     place="Rec/Track/VPTT"/>
      <location name="VeloUT"     place="Rec/Track/VeloUT"/>
      <location name="UT"         place="Rec/Track/UT"/>

      <location name="CaloCosmicsForward"       place="Calo/Track/Forward"/>
      <location name="CaloCosmicsBackward"      place="Calo/Track/Backward"/>
      <location name="HltImport"       place="Red/Track/HLTImport"/>

      <base name='KeyedObject&lt;int&gt;' />
      &KeyedObject;

      <import name='GaudiKernel/GaudiException' />
      <import name='Event/State' />
      <import name='Event/Measurement' />
      <import name='Event/TrackParameters' />
      <import name='Node' soft='FORWARDONLY' />
      <import name='TrackFitResult' soft='FORWARDONLY'/>
      <import name='Kernel/LHCbID' />
      <import name='GaudiKernel/Plane3DTypes' />
      <import name='GaudiKernel/GenericMatrixTypes' />
      <import name="GaudiKernel/VectorMap"/>
      <import name="GaudiKernel/Range"/>
      <import name="GaudiKernel/SharedObjectsContainer"/>

      <enum
        name   = 'History'
        desc   = 'Track history enumerations: each entry corresponds to the name of the pattern recognition algorithm that produced the Track'
        strTypConv = 'TRUE'
        unknownValue = 'HistoryUnknown'
        access = 'PUBLIC' >
        <enumval name = "HistoryUnknown" value="0" desc="unknown history (i.e. history not set)"/>
        <enumval name = "TrackIdealPR"   value="1" desc="track produced with the ideal pattern recognition"/>
        <enumval name = "TrackSeeding"   value="2" desc="track produced with the seeding pattern recognition"/>
        <enumval name = "PatVelo"        value="3" desc="track produced with the 2D then 3D VELO pattern recognition"/>
        <enumval name = "PatVeloTT"      value="4" desc="track produced with the online Velo-TT pattern recognition"/>
        <enumval name = "TrackVeloTT"    value="5" desc="track produced with the offline Velo-TT pattern recognition"/>
        <enumval name = "PatForward"     value="6" desc="track produced with the forward pattern recognition"/>
        <enumval name = "TrackMatching"  value="7" desc=""/>
        <enumval name = "PatKShort"      value="8" desc="track produced with the PatKShort pattern recognition"/>
        <enumval name = "TsaTrack"       value="9" desc=""/>
        <enumval name = "MuonID"         value="10" desc="track produced with the Muon pattern recognition"/>
        <enumval name = "PatVeloR"       value="11" desc="produced with the 2D VELO pattern recognition"/>
        <enumval name = "PatVeloGeneric" value="12" desc="produced with the VELO Generic pattern recognition"/>
        <enumval name = "PatVeloGeneral" value="13" desc="produced with the VELO General pattern recognition"/>
        <enumval name = "PatVeloOpen"    value="14" desc="produced with the VELO open pattern recognition"/>
        <enumval name = "PatSeeding"     value="15" desc="track produced with the PatSeeding pattern recognition"/>
        <enumval name = "PatMatch"       value="16" desc="track produced with the PatMatch pattern recognition"/>
        <enumval name = "PatDownstream"  value="17" desc="track produced with the PatDownstream pattern recognition"/>
        <enumval name = "TTGeneric"      value="18" desc="track produced with the TTGenericTracking algorithm"/>
	<enumval name = "PatVPCheated" value="19" desc="track produced with the CheatedVPPat algorithm"/>
	<enumval name = "HLTImportedTrack" value="20" desc="track imported from HLT to offline"/>
        <enumval name = "PatFastVelo"    value="21" desc="track produced by FastVelo algorithm"/>
        <enumval name = "PatVP"    value="22" desc="track produced by VP algorithm"/>
        <enumval name = "PatVeloUT"      value="23" desc="track produced with the online Velo-UT pattern recognition"/>
        <enumval name = "PrForward"      value="30" desc="track produced with the PrForward pattern recognition for the upgrade"/>
        <enumval name = "PrSeeding"      value="31" desc="track produced with the PrSeeding pattern recognition for the upgrade"/>
        <enumval name = "PrMatch"        value="32" desc="track produced with the PrMatch pattern recognition for the upgrade"/>
        <enumval name = "PrDownstream"   value="33" desc="track produced with the PrDownstream pattern recognition for the upgrade"/>
        <enumval name = "PrVeloUT"       value="34" desc="track produced with the PrVeloUT pattern recognition for the upgrade"/>
      </enum>

      <enum
        name   = 'FitHistory'
        desc   = 'Track fit history enumerations'
        strTypConv = 'TRUE'
        unknownValue = 'FitUnknown'
        access = 'PUBLIC' >
        <enumval name = "FitUnknown" value="0" desc="track not fitted yet (fit history not set)"/>
        <enumval name = "StdKalman"            desc="track fitted with the standard Kalman fitter"/>
        <enumval name = "BiKalman"             desc="track fitted with the bi-directional Kalman fitter"/>
      </enum>

      <enum
        name   = 'Types'
        desc   = 'Track type enumerations'
        strTypConv = 'TRUE'
        unknownValue = 'TypeUnknown'
        access = 'PUBLIC' >
        <enumval name = "TypeUnknown" value="0" desc="track of undefined type"/>
        <enumval name = "Velo"        desc="VELO track"/>
        <enumval name = "VeloR"       desc="2D VELO track"/>
        <enumval name = "Long"        desc="forward track"/>
        <enumval name = "Upstream"    desc="upstream track"/>
        <enumval name = "Downstream"  desc="downstream track"/>
        <enumval name = "Ttrack"      desc="seed track"/>
        <enumval name = "Muon"        desc="muon track"/>
        <enumval name = "Calo"        desc="calo cosmics track"/>
        <enumval name = "TT"          desc="TT track"/>
        <enumval name = "UT"          desc="UT track"/>
      </enum>

      <enum
        name   = 'PatRecStatus'
        desc   = 'Track pattern recognition status flag enumerations: The flag specifies in which state of the pattern recognition phase the track is. The status flag is set by the relevant algorithms'
        strTypConv = 'TRUE'
        unknownValue = 'PatRecStatusUnknown'
        access = 'PUBLIC' >
        <enumval name = "PatRecStatusUnknown" value="0" desc="track in an undefined PR status"/>
        <enumval name = "PatRecIDs"                     desc="pattern recognition track with LHCbIDs"/>
        <enumval name = "PatRecMeas"                    desc="pattern recognition track with Measurements added"/>
      </enum>

      <enum
        name   = 'FitStatus'
        desc   = 'Track fitting status flag enumerations: The flag specifies in which state of the fitting phase the track is. The status flag is set by the relevant algorithms'
        strTypConv = 'TRUE'
        unknownValue = 'FitStatusUnknown'
        access = 'PUBLIC' >
        <enumval name = "FitStatusUnknown" value="0" desc="track in an undefined fitting status"/>
        <enumval name = "Fitted"                     desc="fitted track"/>
        <enumval name = "FitFailed"                  desc="track for which the track fit failed"/>
      </enum>

      <enum
        name   = 'Flags'
        desc   = 'Track general flags enumerations'
        strTypConv = 'TRUE'
        unknownValue = 'FlagsUnknown'
        access = 'PUBLIC' >
        <enumval name = "FlagsUnknown"    value=  "0" desc=""/>
        <enumval name = "Backward"    value=  "1" desc="VELO track in the backward direction"/>
        <enumval name = "Invalid"     value=  "2" desc="invalid track for physics"/>
        <enumval name = "Clone"       value=  "4" desc="clone track (of a corresponding unique track)"/>
        <enumval name = "Used"        value=  "8" desc=""/>
        <enumval name = "IPSelected"  value= "16" desc=""/>
        <enumval name = "PIDSelected" value= "32" desc=""/>
        <enumval name = "Selected"    value= "64" desc=""/>
        <enumval name = "L0Candidate" value="128" desc=""/>
      </enum>
  
      <enum
        desc   = "Additional information assigned to this Track by pattern recognition"
        name   = "AdditionalInfo"
        strTypConv = 'TRUE'
        unknownValue = 'AdditionalInfoUnknown'
        access = "PUBLIC" >

        <enumval name = "AdditionalInfoUnknown" value = "0" desc=""/>
        <enumval name = "DC06Likelihood" value = "1" desc="The Likelihood the track is real. OBSOLETE, may exist on DC06 DSTs and some 2007/09 files"/>
        <enumval name = "PatQuality" value = "2" desc="Quality variable from PatForward Tracking"/>
	<enumval name = "Cand1stQPat"      value = "3"  desc=" Quality of the first candidate"/>
	<enumval name = "Cand2ndQPat"      value = "4"  desc=" Quality of the second candidate"/>
        <enumval name = "NCandCommonHits"  value = "5"  desc=" NCand with common hits"/>
        <enumval name = "Cand1stChi2Mat"   value = "6"  desc=" Chi2 of the first candidate"/>
        <enumval name = "Cand2ndChi2Mat"   value = "7"  desc=" Chi2 of the second candidate"/>
        <enumval name = "DC06nExpectedVelo" value = "10" desc="number of expected Velo hits. OBSOLETE, may exist on DC06 DSTs and some 2007/09 files"/>
        <enumval name = "DC06nExpectedTT" value = "11" desc="number of expected TT hits. OBSOLETE, may exist on DC06 DSTs and some 2007/09 files"/>
        <enumval name = "DC06nExpectedIT" value = "12" desc="number of expected IT hits. OBSOLETE, may exist on DC06 DSTs and some 2007/09 files"/>
        <enumval name = "DC06nExpectedOT" value = "13" desc="number of expected OT hits. OBSOLETE, may exist on DC06 DSTs and some 2007/09 files"/>
        <enumval name = "MatchChi2"  value = "16" desc="Chi2 from the velo-seed matching (TrackMatching)"/>
        <enumval name = "FitVeloChi2"  value = "17" desc="Chi2 of the velo segment (from TrackFitResult)"/>
        <enumval name = "FitVeloNDoF"  value = "18" desc="NDoF of the velo segment chisq"/>
        <enumval name = "FitTChi2"     value = "19" desc="Chi2 of the T station segment (from TrackFitResult)"/>
        <enumval name = "FitTNDoF"     value = "20" desc="NDoF of the T station segment chisq"/>
        <enumval name = "FitMatchChi2" value = "21" desc="Chi2 of the breakpoint between T and TT (from TrackFitResult)"/>
	<enumval name = "FitFracUsedOTTimes" value = "25" desc="Fraction of OT hits for which drifttime is used in fit"/>
	<enumval name = "TsaLikelihood" value = "32" desc ="Likelihood from tsa seeding"/> 
        <enumval name = "CloneDist"  value = "101" desc="Track is flagged as being a (rejected) clone of another track. Value is the KL clone distance"/>
        <enumval name = "DC06GhostProbability" value = "102" desc=" gives the NN ghost probability. OBSOLETE, may exist on DC06 DSTs and some 2007/09 files"/>
        <enumval name = "nPRVeloRZExpect" value = "103" desc="Number of expected Velo clusters from VELO RZ pattern recognition"/>
        <enumval name = "nPRVelo3DExpect" value = "104" desc="Number of expected Velo clusters from VELO 3D pattern recognition"/>
        
        <enumval name = "AdditionalInfo201"  value = "201" desc="OBSOLETE, may exist in some 2008/09 files"/>
        <enumval name = "AdditionalInfo202"  value = "202" desc="OBSOLETE, may exist in some 2008/09 files"/>

        <enumval name = "MuonChi2perDoF"  value = "300" desc="Chi2/nDoF of muon track fit"/>
        <enumval name = "MuonMomentumPreSel"  value = "301" desc="1 if pass Momentum pre-selection, 0 if not"/>
        <enumval name = "MuonInAcceptance"  value = "302" desc="1 if in Muon system InAcceptance, 0 if not"/>
        <enumval name = "IsMuonLoose"  value = "303" desc="1 if pass IsMuonLoose criteria, 0 if not"/>
        <enumval name = "IsMuon"  value = "304" desc="1 if pass IsMuon criteria, 0 if not"/>
        <enumval name = "MuonDist2"  value = "305" desc="Squared distance of the closest muon hit to the extrapolated track"/>
        <enumval name = "MuonDLL"  value = "306" desc="DLL (from muon system only)"/>
        <enumval name = "MuonNShared"  value = "307" desc="NShared (number of additional IsMuon tracks with at least one shared hit with the current track and a smaller Dist value)"/>
        <enumval name = "MuonCLQuality"  value = "308" desc="CLQuality"/>
        <enumval name = "MuonCLArrival"  value = "309" desc="CLArrival"/>
        <enumval name = "IsMuonTight"  value = "310" desc="1 if pass IsMuonTight criteria, 0 if not"/>

       </enum>

   <typedef 
     type = "SharedObjectsContainer&lt;LHCb::Track&gt;"
     def  = "Selection"
     desc = "For defining SharedObjectContainer"
     access = "PUBLIC"
     />
      
   <typedef 
     type = "Gaudi::Range_&lt;ConstVector&gt;"
     def  = "Range"
     desc = "For accessing a list of tracks which is either a SharedObjectContainer, a KeyedContainer or a ConstVector"
     access = "PUBLIC"
     />
      
   <typedef
        type   = "GaudiUtils::VectorMap&lt;int,double&gt;"
        def    = "ExtraInfo"
        desc   = "Vector of additional information"
        access = "PUBLIC"
   />

   <typedef
        type   = "std::vector&lt;LHCb::LHCbID&gt;"
        def    = "LHCbIDContainer"
        desc   = "Container for LHCb::LHCbIDs on track"
        access = "PUBLIC"
   />

   <typedef
        type   = "std::vector&lt;const LHCb::Measurement*&gt;"
        def    = "MeasurementContainer"
        desc   = "Container for LHCb::Measurements on track"
        access = "PUBLIC"
   />

   <typedef
        type   = "std::vector&lt;LHCb::State*&gt;"
        def    = "StateContainer"
        desc   = "Container for LHCb::States on track"
        access = "PUBLIC"
   />

   <typedef
     type   = "Gaudi::Range_&lt;std::vector&lt;const LHCb::Node*&gt; &gt;"
     def    = "ConstNodeRange"
     desc   = "Range of pointers to nodes on track. For non-const access, use fitresult."
     access = "PUBLIC"
     />
	
   <constructor 
	desc     = "Constructor with assigned key" 
	argList  = "int key "
	explicit = "TRUE"
	initList = "KeyedObject&lt;int&gt;( key ), m_chi2PerDoF(0.0), m_nDoF(0), m_likelihood(999), m_ghostProbability(999), m_flags(0), m_lhcbIDs(), m_states(), m_fitResult(0), m_ancestors()">
      </constructor>

  <constructor 
	desc     = "Constructor" 
	argList  = "const LHCb::Track::History&amp; history, 
                    const LHCb::Track::Types&amp; trackType,  const LHCb::Track::PatRecStatus&amp; patStatus,
                    std::vector&lt;LHCb::LHCbID&gt; ids,
                    const LHCb::State&amp; aState"
	explicit = "TRUE"
	initList = "KeyedObject&lt;int&gt;(), m_chi2PerDoF(0.0), m_nDoF(0), m_likelihood(999), m_ghostProbability(999), m_flags(0), m_lhcbIDs(ids), m_states(), m_fitResult(0), m_ancestors()">
      <code>
  #ifdef __INTEL_COMPILER         // Disable ICC remark
    #pragma warning(disable:1572) // Floating-point equality and inequality comparisons are unreliable
    #pragma warning(push)
  #endif
      addToStates(aState);
      setHistory(history);
      setType(trackType);
      setPatRecStatus( patStatus ); 
      std::sort( m_lhcbIDs.begin(),m_lhcbIDs.end() ) ; 
      </code>
      </constructor>

  <constructor 
	desc     = "Constructor" 
	argList  = "const LHCb::Track::History&amp; history, const LHCb::Track::Types&amp; trackType,
                    const LHCb::Track::PatRecStatus&amp; patStatus"
	explicit = "TRUE"
	initList = "KeyedObject&lt;int&gt;(), m_chi2PerDoF(0.0), m_nDoF(0), m_likelihood(999), m_ghostProbability(999), m_flags(0), m_lhcbIDs(), m_states(), m_fitResult(0), m_ancestors()">
      <code>
      setHistory(history);
      setType(trackType);
      setPatRecStatus( patStatus ); 
      </code>
      </constructor>

    <constructor 
       desc     = "Copy constructor" 
       initList = "KeyedObject&lt;int&gt;(), m_chi2PerDoF(0.0), m_nDoF(0), m_likelihood(999), m_ghostProbability(999), m_flags(0), m_lhcbIDs(), m_states(), m_fitResult(0), m_ancestors()">
         <arg const="TRUE" name="track" type="LHCb::Track"/>
       <code>
         this -&gt; copy( track ); 
       </code>
    </constructor>

      <destructor
        desc = 'Track destructor'>
        <code>
  reset();
        </code>
      </destructor>

      <attribute
        type   = 'double'
        name   = 'chi2PerDoF'
        desc   = 'Chi^2 per degree of freedom of the track'
        access = 'PROTECTED' /> 

      <attribute
        type   = 'int'
        name   = 'nDoF'
        desc   = 'Number of degrees of freedom of the track'
        access = 'PROTECTED' />

      <attribute
        type   = 'double'
        name   = 'likelihood'
        desc   = 'Likelihood variable'
        init   = '999'
        access = 'PROTECTED' />

       <attribute
        type   = 'double'
        name   = 'ghostProbability'
        desc   = 'ghost probability variable'
        init   = '999'
        access = 'PROTECTED' />
    
     <attribute
       type    = 'bitfield'
       name    = 'flags'
       desc    = 'The variety of track flags'
       init    = '0'
       access  = 'PROTECTED'>
       <bitfield
         type      = 'LHCb::Track::Types'
         name      = 'type'
         length    = '4'
         desc      = 'Track type'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::History'
         name      = 'history'
         length    = '7'
         desc      = 'Specifies the pattern recognition algorithm that created the track'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::FitHistory'
         name      = 'fitHistory'
         length    = '3'
         desc      = 'Specifies the fitting algorithm the fitted the track)'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::PatRecStatus'
         name      = 'patRecStatus'
         length    = '2'
         desc      = 'Pattern recognition status of the track'
	 setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::FitStatus'
         name      = 'fitStatus'
         length    = '2'
         desc      = 'Fitting status of the track'
	 setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         type      = 'LHCb::Track::Flags'
         name      = 'flag'
         length    = '10'
         desc      = 'Track flags'
         setMeth   = 'FALSE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
       <bitfield
         name      = 'specific'
         length    = '4'
         desc      = 'Track specific bits'
         setMeth   = 'TRUE'
         getMeth   = 'TRUE'
         checkMeth = 'FALSE' />
      </attribute>

      <attribute
        type      = 'std::vector&lt;LHCb::LHCbID&gt;'
        name      = 'lhcbIDs'
        desc      = 'Container of (sorted) LHCbIDs'
        access    = 'PROTECTED'
        setMeth   = 'FALSE' />

      <attribute
        type      = 'std::vector&lt;LHCb::State*&gt;'
        name      = 'states'
        desc      = 'Container with pointers to all the states'
        access    = 'PROTECTED'
        setMeth   = 'FALSE' />

      <attribute
	type      = 'LHCb::TrackFitResult*'
        name      = 'fitResult'
        desc      = 'Transient data related to track fit (nodes, material, etc)'
        access    = 'PROTECTED'
        setMeth   = 'FALSE'
	getMeth   = 'FALSE'
        transient = 'TRUE' />

      <attribute
        name    = "extraInfo"
        desc    = "Additional pattern recognition information. Do not access directly, use *Info() methods instead."
        type    = "ExtraInfo"
        getMeth = "TRUE"
        access  = "PROTECTED" />

      <relation
        type         = 'LHCb::Track'
        name         = 'ancestors'
        desc         = 'Ancestor tracks that created this one'
        access       = 'PROTECTED'
        setMeth      = 'FALSE'
        multiplicity = 'N'
	nonconstaccessor = 'TRUE' />

      <method
        type    = 'void'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors and the corresponding 6D covariance matrix (pos:0->2,mom:3-5) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::XYZVector' name='mom' />
        <arg type = 'Gaudi::SymMatrix6x6' name='cov6D' />
        <code>
 firstState().positionAndMomentum( pos, mom, cov6D );
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'positionAndMomentum'
        desc    = 'Retrieve the position and momentum vectors at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::XYZVector' name='mom' />
       <code>
 firstState().positionAndMomentum( pos, mom );
       </code>
      </method>

      <method
        type    = 'Gaudi::XYZPoint'
        name    = 'position'
        desc    = 'Retrieve the 3D-position vector at the first state'
        const   = 'TRUE'>
        <code>
  return firstState().position();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'position'
        desc    = 'Retrieve the 3D-position (+ errors) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZPoint' name='pos' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errPos' />
       <code>
  pos    = firstState().position();
  errPos = firstState().errPosition();
       </code>
      </method>

    <method
        type    = 'Gaudi::XYZVector'
        name    = 'slopes'
        desc    = 'Retrieve the slopes (Tx=dx/dz,Ty=dy/dz,1.) and errors at the first state'
        const   = 'TRUE'>
        <code>
   return firstState().slopes();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'slopes'
        desc    = 'Retrieve the slopes (Tx=dx/dz,Ty=dy/dz,1.) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZVector' name='slopes' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errSlopes' />
        <code>
   slopes    = firstState().slopes();
   errSlopes = firstState().errSlopes();
        </code>
      </method>

      <method
        type    = 'Gaudi::XYZVector'
        name    = 'momentum'
        desc    = 'Retrieve the momentum vector at the first state'
        const   = 'TRUE'>
        <code>
  return this->firstState().momentum();
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'p'
        desc    = 'Retrieve the momentum at the first state'
        const   = 'TRUE'>
        <code>
  return this->firstState().p();
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'pt'
        desc    = 'Retrieve the transverse momentum at the first state'
        const   = 'TRUE'>
        <code>
  return this->firstState().pt();
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'pseudoRapidity'
        desc    = 'Retrieve the pseudorapidity at the first state'
        const   = 'TRUE'>
        <code>
  return this->slopes().eta() ;
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'phi'
        desc    = 'Retrieve the phi at the first state'
        const   = 'TRUE'>
        <code>
  return this->slopes().phi() ;
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'momentum'
        desc    = 'Retrieve the momentum vector (and errors) at the first state'
        const   = 'TRUE'>
        <arg type = 'Gaudi::XYZVector' name='mom' />
        <arg type = 'Gaudi::SymMatrix3x3' name='errMom' />
        <code>
  mom    = firstState().momentum();
  errMom = firstState().errMomentum();
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'posMomCovariance'
        desc    = 'Retrieve the 6D (x,y,z,px,py,pz) covariance matrix at the first state'
        const   = 'TRUE'>
        <arg type='Gaudi::SymMatrix6x6' name='cov6D' />
        <code>
 cov6D = firstState().posMomCovariance();
        </code>
      </method>

      <method
        type    = 'LHCb::State &amp;'
        name    = 'firstState'
        desc    = 'Retrieve the first state on the track'
        const   = 'FALSE'>
        <code>
  // check at least the &quot;first state&quot; exists
  if ( m_states.empty() )
    throw GaudiException( &quot;first state not defined!&quot;,
                          &quot;Track.h&quot;,
                          StatusCode::FAILURE );
  return *m_states[0];
        </code>
      </method>
      <method
        type    = 'const LHCb::State &amp;'
        name    = 'firstState'
        desc    = 'Retrieve the first state on the track'
        const   = 'TRUE'>
        <code>
  // check at least the &quot;first state&quot; exists
  if ( m_states.empty() )
    throw GaudiException( &quot;first state not defined!&quot;,
                          &quot;Track.h&quot;,
                          StatusCode::FAILURE );
  return *m_states[0];
        </code>
      </method>

      <method
        type    = 'int'
        name    = 'charge'
        desc    = 'Retrieve the charge assigned to the track'
        const   = 'TRUE'>
        <code>
  double qP = firstState().qOverP();
  return ( fabs(qP)  &gt; TrackParameters::lowTolerance  ? int(fabs(qP)/qP) : 0 );
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'chi2'
        desc    = 'Retrieve the Chi^2 of the track (fit)'
        const   = 'TRUE'>
        <code>
  return ( m_chi2PerDoF * double(m_nDoF) );
        </code>
      </method>

      <method
        type    = 'void'
        name    = 'setChi2AndDoF'
        desc    = 'Set the Chi^2 and the DoF of the track (fit)'
        argList = 'double chi2, int ndof'
        const   = 'FALSE'>
        <code>
  m_chi2PerDoF = ( ndof != 0 ) ? chi2/((double) (ndof)) : 0.0;
  m_nDoF = ndof;
        </code>
      </method>

      <method
        type    = 'double'
        name    = 'probChi2'
        desc    = 'Probability of chi2^2 of the track'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nStates'
        desc    = 'Retrieve the number of states on the track'
        const   = 'TRUE'>
        <code>
  return m_states.size();
        </code>
      </method>
      
      <method
        type    = 'MeasurementContainer'
        name    = 'measurements'
        desc    = 'Retrieve vector with measurements on the track'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'ConstNodeRange'
        name    = 'nodes'
        desc    = 'Const retrieve the nodes on the track'
        const   = 'TRUE'>
      </method>

      <method
        name    = 'addToStates'
        desc    = 'Add a State to the list of States associated to the track'>
        <arg type = 'const LHCb::State' name=' state' />
      </method>

     <method
        name    = 'addToStates'
        desc    = 'Add a set of states to the track. Track takes ownership.'>
        <arg type = 'StateContainer' name='states' />
      </method>

      <method
        name    = 'removeFromStates'
        desc    = 'Remove a State from the list of states associated to the track'
        argList = 'LHCb::State* value'>
      </method>

      <method
        type    = 'void'
        name    = 'clearStates'
        desc    = 'Clear the State vector'>
      </method>

      <method
        type    = 'LHCb::State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position'
        const   = 'FALSE' />

      <method
        type    = 'const LHCb::State &amp;'
        name    = 'closestState'
        argList = 'double z'
        desc    = 'Retrieve the reference to the state closest to the given z-position'
        const   = 'TRUE' />

      <method
        type    = 'const LHCb::State &amp;'
        name    = 'closestState'
        argList = 'const Gaudi::Plane3D plane'
        desc    = 'Retrieve the reference to the state closest to the given plane'
        const   = 'TRUE' />

      <method
        type    = 'bool'
        name    = 'hasStateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Check the existence of a state at a certain predefined location (see the Location enum in State.h)'
        const   = 'TRUE' />

      <method
        type    = 'LHCb::State*'
        name    = 'stateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Retrieve the state at a certain predefined location (see the Location enum in State.h)' />

      <method
        type    = 'const LHCb::State*'
        name    = 'stateAt'
        argList = 'const LHCb::State::Location&amp; location'
        desc    = 'Retrieve the const state at a certain predefined location (see the Location enum in State.h)'
        const   = 'TRUE' />

      <method
        type    = 'unsigned int'
        name    = 'nLHCbIDs'
        desc    = 'Retrieve the number of LHCbIDs on the track'
        const   = 'TRUE'>
        <code>
  return m_lhcbIDs.size();
        </code>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nMeasurements'
        desc    = 'Retrieve the number of Measurements on the track'
        const   = 'TRUE'>
      </method>

     <method
       name    = 'addToLhcbIDs'
       desc    = 'Add an LHCbID to the list of LHCbIDs associated to the track. Return true if LHCbID was not yet on track.'
       type    = 'bool'
       argList = 'LHCb::LHCbID value'>
      </method>

     <method
       name    = 'addSortedToLhcbIDs'
       desc    = 'Add a sorted (!) vector of LHCbID to the list of LHCbIDs associated to the track. Returns true if none of the LHCb ids was on the track.'
       type    = 'bool'
       argList = 'LHCbIDContainer value'>
      </method>

     <method
       name    = 'addToLhcbIDs'
       desc    = 'Add an unsorted vector of LHCbID to the list of LHCbIDs associated to the track. The vector will first be sorted, which makes this more expensive than the method above. Returns true if none of the LHCb ids was on the track.'
       type    = 'bool'
       argList = 'LHCbIDContainer value'>
<code>
  LHCbIDContainer copy(value) ;
  std::sort( copy.begin(), copy.end() ) ;
  return addSortedToLhcbIDs( copy ) ;
</code>
      </method>

     <method
       name    = 'setLhcbIDs'
       desc    = 'Sets the list of LHCbIDs associated to this track. The input vector will be sorted.'
       argList = 'LHCbIDContainer value'>
<code>
  m_lhcbIDs = value ;
  std::sort( m_lhcbIDs.begin(), m_lhcbIDs.end() ) ;
</code>
      </method>

     <method
       name    = 'setSortedLhcbIDs'
       desc    = 'Sets the list of LHCbIDs associated to this track. The input vector must be sorted.'
       argList = 'LHCbIDContainer value'>
<code>
  m_lhcbIDs = value ;
</code>
      </method>

     <method
       name    = 'containsLhcbIDs'
       desc    = 'Returns true if the LHCbIDs of track are a subset is the LHCbIDs of this track.'
       type    = 'bool'
       const   = 'TRUE'
       argList = 'Track track'>
<code>
  return containsLhcbIDs( track.lhcbIDs() ) ;
</code>
      </method>

       <method
       name    = 'containsLhcbIDs'
       desc    = 'Returns true if LHCbIDs in ids are a subset of the LHCbIDs of this track.'
       type    = 'bool'
       const   = 'TRUE'
       argList = 'LHCbIDContainer ids'>
<code>
  return std::includes( m_lhcbIDs.begin(),m_lhcbIDs.end(),
                        ids.begin(),ids.end() ) ;
</code>
      </method>

       <method
       name    = 'nCommonLhcbIDs'
       desc    = 'Returns the number of common LHCbIDs.'
       type    = 'size_t'
       const   = 'TRUE'
       argList = 'Track track'>
      </method>
      
     <method
        name    = 'removeFromLhcbIDs'
        desc    = 'Remove an LHCbID from the list of LHCbIDs associated to the track'
        argList = 'LHCbID value' />

      <method
        name    = 'addToAncestors'
        desc    = 'Add a track to the list of ancestors of this track'>
        <arg type = 'const LHCb::Track ' name='ancestor' />
        <code>
  m_ancestors.push_back( (LHCb::Track*) &amp;ancestor );
        </code>
      </method>

      <method
	type    = 'void'
        name    = 'setFitResult'
        desc    = 'Set pointer to object holding track fit data. Track becomes owner.'>
	  <arg type = 'LHCb::TrackFitResult* ' name='trackfit' />
      </method>
 
      <method
	type    = 'TrackFitResult*'
        name    = 'fitResult'
        desc    = 'get pointer to the object holding the trackfit data.'>
      </method>
	
      <method
	type    = 'const TrackFitResult*'
	name    = 'fitResult'
	desc    = 'get const pointer to the object holding the trackfit data.'
	const   = 'TRUE'>
      </method>
	
      <method
        type    = 'void'
        name    = 'reset'
        desc    = 'Clear the track before re-use'
	virtual = 'TRUE'>
      </method>

      <method
        type    = 'LHCb::Track*'
        name    = 'cloneWithKey'
        desc    = 'Clone the track keeping the key (you take ownership of the pointer)'
	const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        type    = 'LHCb::Track*'
        name    = 'clone'
        desc    = 'Clone the track (you take ownership of the pointer)'
	const   = 'TRUE'
        virtual = 'TRUE' />

      <method
        type    = 'void'
        name    = 'copy'
        argList = 'const LHCb::Track&amp; track'
        desc    = 'Copy the info from the argument track into this track'
	virtual = 'TRUE' />

      <method
        type    = 'bool'
        name    = 'checkType'
        argList = 'const LHCb::Track::Types&amp; value'
        desc    = 'Check the type of the track (see the Types enum)'
        const   = 'TRUE'>
        <code>
  return type() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkHistory'
        argList = 'const LHCb::Track::History&amp; value'
        desc    = 'Check the history of the track (see the History enum)'
        const   = 'TRUE'>
        <code>
  return history() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFitHistory'
        argList = 'const LHCb::Track::FitHistory&amp; value'
        desc    = 'Check the fit history of the track (see the FitHistory enum)'
        const   = 'TRUE'>
        <code>
  return fitHistory() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkPatRecStatus'
        argList = 'const LHCb::Track::PatRecStatus&amp; value'
        desc    = 'Check the pattern recognition status of the track (see the PatRecStatus enum)'
        const   = 'TRUE'>
        <code>
  return patRecStatus() == value;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFitStatus'
        argList = 'const LHCb::Track::FitStatus&amp; value'
        desc    = 'Check the fitting status of the track (see the FitStatus enum)'
        const   = 'TRUE'>
        <code>
  return fitStatus() == value;
        </code>
      </method>

      <method
        name    = 'setFlag'
        argList = 'unsigned int flag, bool ok'
        desc    = 'Update the flag (see the Flags enum)'>
        <code>
  unsigned int val = (((unsigned int) flag) &lt;&lt; flagBits) &amp; flagMask;
  if (ok) m_flags |= val;
  else m_flags &amp;= ~val;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'checkFlag'
        argList = 'const LHCb::Track::Flags&amp; flag'
        desc    = 'Check the status of the flag (see the Flags enum)'
        const   = 'TRUE'>
        <code>
  unsigned int val = ((unsigned int) flag &lt;&lt; flagBits);  
  bool ok = (0 != ( m_flags &amp; flagMask &amp; val ));
  return ok;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'hasT'
        desc    = 'Check if track is of a type that goes thro T stations'
        const   = 'TRUE'>
        <code>
          bool hasTPart = false;
          if (type() == Track::Ttrack 
          || type() == Track::Downstream 
          || type() == Track::Long) hasTPart = true;
          return hasTPart;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'hasVelo'
        desc    = 'Check if track is of a type that goes thro Velo'
        const   = 'TRUE'>
        <code>
          bool hasVPart = false;
          if (type() == Track::Velo 
          || type() == Track::VeloR
          || type() == Track::Upstream 
          || type() == Track::Long) hasVPart = true;
          return hasVPart;
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'hasTT'
        desc    = 'Check if track is of a type that goes thro TT'
        const   = 'TRUE'>
        <code>
          bool hasTTPart = false;
          if (type() == Track::Downstream 
          || type() == Track::Upstream 
          || type() == Track::Long) hasTTPart = true;
          return hasTTPart;
  #ifdef __INTEL_COMPILER // End disable ICC remark
    #pragma warning(pop)
  #endif
        </code>
      </method>

      <method
        type    = 'bool'
        name    = 'hasUT'
        desc    = 'Check if track is of a type that goes thro UT'
        const   = 'TRUE'>
        <code>
          bool hasUTPart = false;
          if (type() == Track::Downstream 
          || type() == Track::Upstream 
          || type() == Track::Long) hasUTPart = true;
          return hasUTPart;
        </code>
      </method>

      <method
        type    = 'unsigned int'
        name    = 'nMeasurementsRemoved'
        desc    = 'Retrieve the number of Measurements removed by the track fit (the number of LHCbIDs remains unchanged)'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'bool'
        name    = 'isOnTrack'
        argList = 'const LHCb::LHCbID value'
        desc    = 'Check whether the given LHCbID is on the track'
        const   = 'TRUE'>
      </method>

      <method
        type    = 'const LHCb::Measurement*'
        name    = 'measurement'
        argList = 'const LHCb::LHCbID value'
        desc    = 'Return the measurement on the track corresponding to the input LHCbID. Call first the "isMeasurementOnTrack" method before calling this one, as it throws an exception if the LHCbID is not present! (ONLY for tracking code, not for general use.)'
        const   = 'TRUE' />

      <method
	name      = "fillStream"
	desc      = "printOut method to Gaudi message stream"
	type      = "std::ostream&amp;"
	virtual   = "TRUE"
	const     = "TRUE" >
	<arg name = "os" type = "std::ostream" inout = "BOTH"/>
      </method>

      <method
        name    = "hasInfo"
        const   = "TRUE"
        desc    = "Check whether the track has information for the specified key"
        argList = "const int key"
        type    = "bool" />

       <method
        name    = "addInfo"
        desc    = "Add new information, associated with the specified key. This method cannot be used to modify information for an already existing key"
        argList = "const int key, const double info"
        type    = "bool"
       />

       <method
        name    = "info"
        desc    = "Extract the information associated with the specified key. If there is no such information the default value will be returned."
        argList = "const int key, const double def"
        type    = "double"
        const   = "TRUE"
       />

       <method
        name    = "eraseInfo"
        desc    = "Erase the information associated with the specified key"
        argList = "const int key"
        type    = "Track::ExtraInfo::size_type"
       />


    </class>

  </package>
</gdd>
